# Итоговый отчёт по Лабораторной работе №2

---

## Сведения о студенте  
**Дата:** [2025-11-19]  
**Семестр:** [2 курс, 3 семестр]  
**Группа:** [Пин-б-о-24-1]  
**Дисциплина:** [Технологие програмирования]  
**Студент:** [Иванников Сергей Сергеевич]  

---

## Цель курса  
Освоить основные парадигмы программирования и их практическую реализацию на языке R и среде Scratch. Изучить эволюцию подходов к разработке программного обеспечения от низкоуровневых до современных высокоуровневых методологий.

---

## Обзор изученных парадигм программирования

### 1. Императивное (процедурное) программирование

**Суть парадигмы:** Программа как последовательность команд, изменяющих состояние памяти.

**Ключевой пример:**
```r
S_kvadrat <- function(a) {
    return(a^2)
}
S_Kryg <- function(r, pi) {
    return(r^2 * pi)
}
```
*Данный код демонстрирует классический процедурный подход - разбиение задачи на отдельные функции, каждая из которых выполняет конкретную операцию.*

**Вывод**: Процедурное программирование обеспечивает простоту и линейность выполнения, но становится громоздким при увеличении сложности программы.

### 2. Структурное программирование

**Суть парадигмы:** Организация кода через иерархическую структуру блоков.

Ключевой пример:
```r
k <- 0
while(TRUE){
    if (k == 3){
        print("1234")
        break
    }
    a <- readline()
    if (grepl("^\\d+$", a)){
        number <- as.integer(a)
        print(number^2)
        break
    }
    else{
        k <- k + 1
    }
}
```
*Код показывает использование структурных элементов: цикл `while`, условные операторы `if-else`, что делает программу более читаемой и управляемой.*

**Вывод:** Структурное программирование устраняет хаотичность кода через четкие управляющие конструкции, повышая надежность и сопровождаемость.

### 3. Объектно-ориентированное программирование

**Суть парадигмы:** Программа как совокупность взаимодействующих объектов.

Ключевой пример:
```r
Circle <- R6Class(
    "Circle",
    inherit = Figyra,
    public = list(
        initialize = function(radius) {
            if (radius <= 0) stop("Радиус должен быть положительным")
            super$initialize(c(radius = radius))
        },
        calculate_area = function() {
            radius <- self$parameters["radius"]
            area <- pi * radius^2
            return(area)
        }
    )
)
```
*Пример показывает инкапсуляцию данных и поведения в классе, наследование и полиморфизм через переопределение метода `calculate_area()`*

**Вывод:** ООП позволяет создавать сложные системы через композицию объектов, обеспечивая модульность и повторное использование кода.

### 4. Векторное программирование
Суть парадигмы: Поэлементное одновременное выполнение операций над данными.

Ключевой пример:
```r
my_vector2 <- c()
for (i in my_vector) {
    if (abs(sred - i) < a) {
        my_vector2 <- c(my_vector2, i)
    }
}
```
*Хотя здесь используется цикл, в R типично применять векторизованные операции типа*`my_vector[abs(mean(my_vector) - my_vector) < sd(my_vector)]`

**Вывод:** Векторизация значительно ускоряет обработку данных, устраняя накладные расходы циклов, что особенно важно при работе с большими наборами данных.

### 5. Функциональное программирование
Суть парадигмы: Программирование без изменения состояния, с использованием функций.

Ключевой пример:
```r
title <- map_chr(sw_films, "title")
named_films <- set_names(sw_films, title)
named_films2 <- sw_films %>% 
  set_names(map_chr(., "title"))
```
*Код демонстрирует функциональный стиль: цепочки преобразований, отсутствие промежуточных переменных, использование функций высшего порядка `map_chr`.*

**Вывод:** Функциональное программирование обеспечивает чистоту кода и предсказуемость результатов, упрощая тестирование и отладку.

### 6. Грамотное программирование

Суть парадигмы: Создание документов, объединяющих код, результаты и объяснения.

Ключевой пример:

```markdawn
Средняя скорость автомобилей составляет `r round(avg_speed, 1)` миль/ч,
что равно `r round(avg_speed * 1.60934, 1)` км/ч.
```

*Inline-код в R Markdown позволяет динамически вставлять вычисленные значения в текст, обеспечивая актуальность документа при изменении данных.*

**Вывод:** Грамотное программирование повышает воспроизводимость исследований и качество документации, объединяя код и его описание.

### 7. Параллельное программирование
Суть парадигмы: Одновременное выполнение вычислений для ускорения обработки.

Ключевой пример:

```r
cl <- makeCluster(ncores)
clusterExport(cl, "mean_of_rnorm")
result2 <- parLapply(cl, 1:50, function(x) mean_of_rnorm(10000))
stopCluster(cl)
```

*Создание кластера и распределение задач между ядрами процессора демонстрирует модель параллельных вычислений master-worker.*

**Вывод:** Параллельное программирование критически важно для эффективного использования современных многопроцессорных систем и обработки больших данных.

8. Визуальное программирование
Суть парадигмы: Создание программ через манипуляцию графическими элементами.

Ключевой пример:

![Код мяча](./код_мяча.png)

*Визуальные блоки Scratch представляют программные конструкции интуитивно понятным образом, снижая порог входа в программирование.*

**Вывод:** Визуальное программирование делает алгоритмы наглядными и доступными для начинающих, служа эффективным образовательным инструментом.

### Эволюция подходов к программированию

## От низкоуровневого к высокоуровневому

Курс продемонстрировал естественную эволюцию от:

- Ассемблерного уровня (управление регистрами и памятью)
- Процедурного подхода (последовательность команд)
- Структурного программирования (иерархия блоков)
- Объектной ориентации (взаимодействие объектов)
- Функциональных методов (композиция операций)
- Декларативных подходов (грамотное и визуальное программирование)
- Пример эволюции на задаче вычисления площади:

Пример эволюции на задаче вычисления площади:
```r
# Процедурный подход
S_kvadrat <- function(a) { return(a^2) }

# ООП подход
Kvadrat$new(5)$calculate_area()

# Функциональный подход
map_dbl(sides, ~ .x^2)
```
*Разные парадигмы предлагают различные способы решения одной и той же задачи, каждый со своими преимуществами.*

### Выводы
1. Многообразие подходов - не существует "универсальной" парадигмы программирования, каждая имеет свою область применения. Например, для быстрой обработки данных оптимален функциональный стиль, а для моделирования предметной области - ООП.

2. Прагматизм в выборе - эффективный разработчик должен владеть multiple парадигмами и выбирать appropriate подход для конкретной задачи. Как показали примеры кода, одна задача может решаться разными способами.

3. Эволюционная преемственность - современные парадигмы развиваются из предыдущих, сохраняя лучшие практики и решая их limitations. От процедурного к ООП и функциональному - каждый этап приносил новые возможности.

4. Практическая ориентированность - изучение парадигм через практическую реализацию на конкретных языках обеспечивает глубокое понимание. Работы с R и Scratch дали hands-on опыт применения теоритических концепций.

5. Важность инструментов - современная разработка требует владения не только языками программирования, но и сопутствующими инструментами и средами. R Markdown, пакет parallel, Scratch - каждый инструмент расширяет возможности разработчика.

Приобретенные знания и навыки составляют прочный фундамент для дальнейшего профессионального развития в области разработки программного обеспечения и анализа данных. Курс показал, что современный программист должен быть "полиглотом" в области парадигм программирования, способным выбирать и комбинировать подходы для эффективного решения разнообразных задач.

