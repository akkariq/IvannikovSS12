# Отчёт по лабораторной работе №1  
**Тема:** Реализация принципов ООП на примере системы учета сотрудников 

---

## Сведения о студенте  
**Дата:** [2025-10-30]  
**Семестр:** [2 курс, 1 семестр]  
**Группа:** [Пин-б-о-24-1]  
**Дисциплина:** [Технологие програмирования]  
**Студент:** [Иванников Сергей Сергееевич]  

---

## Цель работы
Освоить базовые принципы объектно-ориентированного программирования (ООП) на языке Python. Получить практические навыки создания иерархии классов, применения принципов инкапсуляции, наследования, полиморфизма и композиции для моделирования предметной области.

---

## Ход работы
## Часть 1: Инкапсуляция
**Цель**  
Реализовать базовый класс `Employee` с инкапсуляцией данных и валидацией.

**Выполненные задачи**
1. Создан класс AbstractEmployee с приватными атрибутами
2. Реализованы свойства (property) для доступа к данным
3. Добавлена валидация входных параметров через класс Validator
4. Реализован метод __str__ для строкового представления

**Ключевые элементы реализации**

```python
class AbstractEmployee(ABC):
    _existing_ids = set()

    def __init__(self, id, name, department, base_salary, skip_validation=False):
        if not skip_validation:
            Validator.validate_employee_id(id, self._existing_ids)
            self._existing_ids.add(id)
        
        Validator.validate_salary(base_salary)

        self.__id = id
        self.__name = name
        self.__department = department
        self.__base_salary = base_salary

    @property
    def id(self):
        return self.__id

    @id.setter
    def id(self, id):
        if id > 0:
            self.__id = id
        else:
            print("Число отрицательное")
```

**Результаты тестирования**
- Протестирована корректная установка и получение значений через свойства
- Проверена обработка невалидных данных (отрицательные ID, пустые имена)
- Убедились в корректности строкового представления

## Часть 2: Наследование и Абстракция

### Цель  

Расширить систему учета сотрудников, создав иерархию классов на основе наследования и абстракции.

**Выполненные задачи**
1. Создан абстрактный класс AbstractEmployee с абстрактными методами
2. Реализованы классы-наследники: Manager, Developer, Salesperson
3. Переопределены методы расчета зарплат для каждого типа сотрудников
4. Реализована фабрика сотрудников EmployeeFactory

**Иерархия классов**

```
AbstractEmployee (ABC)
├── Employee
├── Manager
├── Developer
└── Salesperson
```

**Пример реализации классов-наследников**

```python
class Manager(Employee):
    def __init__(self, id, name, department, base_salary, bonus, skip_validation=False):
        self.__bonus = bonus
        super().__init__(id, name, department, base_salary, skip_validation)

    def calculate_salary(self):
        return self.base_salary + self.__bonus

class Developer(Employee):
    def calculate_salary(self):
        if self.__seniority_level == "junior":
            return self.base_salary
        if self.__seniority_level == "middle":
            return self.base_salary * 1.5
        if self.__seniority_level == "senior":
            return self.base_salary * 2
```

**Фабричный метод**

```python
class EmployeeFactory:
    def create_employee(**emp_type):
        if "manager" in emp_type:
            pp = emp_type["manager"]
            manager = Manager(pp[0],pp[1],pp[2],pp[3],pp[4])
            return manager.get_info()
        # ... аналогично для других типов
```

## Часть 3: Полиморфизм и Магические методы
### Цель
Реализовать полиморфное поведение объектов различных классов сотрудников и освоить перегрузку операторов.

**Выполненные задачи**
1. Создан класс `Department` для управления сотрудниками
2. Реализованы магические методы для сотрудников и отделов
3. Добавлена поддержка сериализации/десериализации
4. Реализована итерация по объектам
5. Созданы компараторы для сортировки

**Магические методы для сотрудников**

```python
def __eq__(self, other) -> bool:
    if not isinstance(other, AbstractEmployee):
        return False
    return self.id == other.id

def __lt__(self, other) -> bool:
    if not isinstance(other, AbstractEmployee):
        return NotImplemented
    return self.calculate_salary() < other.calculate_salary()

def __add__(self, other) -> float:
    if not isinstance(other, AbstractEmployee):
        return NotImplemented
    return self.calculate_salary() + other.calculate_salary()
```

### Класс Department

```python
class Department:
    def __init__(self, name: str):
        self.name = name
        self.spis: List[AbstractEmployee] = []

    def add_employee(self, employee: AbstractEmployee) -> None:
        self.spis.append(employee)

    def __len__(self):
        return len(self.spis)
    
    def __getitem__(self, key) -> AbstractEmployee:
        for i in self.spis.copy():
            if i.id == key:
                return i
    
    def __contains__(self, employee: AbstractEmployee) -> bool:
        return any(emp.id == employee.id for emp in self.spis)
```

**Сериализация и десериализация**

```python
def to_dict(self) -> dict:
    return {
        'id': self.id,
        'name': self.name,
        'department': self.department,
        'base_salary': self.base_salary,
        'calculated_salary': self.calculate_salary(),
        'type': self.__class__.__name__
    }

@classmethod
def from_dict(cls, data: dict) -> 'AbstractEmployee':
    employee_type = data.get('type', 'Employee')
    if employee_type == 'Manager':
        return Manager.from_dict(data)
    # ... аналогично для других типов
```

## Часть 4: Композиция, Агрегация и Работа со сложными структурами
### Цель
Освоить принципы композиции и агрегации для построения сложных объектных структур.

**Выполненные задачи**
1. Создан класс `Project` с композицией сотрудников
2. Реализован класс `Company` с агрегацией отделов и проектов
3. Добавлена система валидации и кастомные исключения
4. Реализована комплексная сериализация системы
5. Добавлены методы анализа и отчетности

Класс Project (композиция)
```python
class Project:
    _existing_project_ids = set()
    _valid_statuses = ["planning", "active", "completed", "cancelled"]
    
    def __init__(self, project_id, name, description, deadline, status, team = []):
        Validator.validate_project_id(project_id, self._existing_project_ids)
        self._existing_project_ids.add(project_id)
        Validator.validate_status(status, self._valid_statuses)
        Validator.validate_date(deadline)
        
        self.project_id = project_id
        self.name = name
        self.description = description
        self.deadline = deadline
        self.status = status
        self.__team = team  # Композиция: команда принадлежит проекту
```

Класс Company (агрегация)

```python
class Company:
    def __init__(self, name: str, departments: list[Department] = [], projects: list[Project] = []):
        self.name = name
        self.__departments = departments  # Агрегация: отделы существуют независимо
        self.__projects = projects        # Агрегация: проекты существуют независимо

    def add_department(self, department_or_name) -> Department:
        if isinstance(department_or_name, Department):
            department = department_or_name
            name = department.name
        else:
            department = Department(department_or_name)
            name = department_or_name
        
        if any(dept.name == name for dept in self.__departments):
            raise DuplicateIdError(f"Отдел с названием '{name}' уже существует в компании")
        
        self.__departments.append(department)
        return department
```

**Кастомные исключения**
```python
class EmployeeNotFoundError(Exception):
    pass

class DepartmentNotFoundError(Exception):
    pass

class ProjectNotFoundError(Exception):
    pass

class InvalidStatusError(Exception):
    pass

class DuplicateIdError(Exception):
    pass
```

**Комплексная сериализация**
```python
def save_to_json(self, filename: str) -> None:
    company_data = self.to_dict()
    with open(filename, 'w', encoding='utf-8') as file:
        json.dump(company_data, file, ensure_ascii=False, indent=2)

def export_employees_csv(self, filename: str) -> None:
    with open(filename, 'w', newline='', encoding='utf-8') as file:
        writer = csv.writer(file)
        writer.writerow(['ID', 'Имя', 'Отдел', 'Должность', 'Базовая зарплата', 'Итоговая зарплата'])
        for department in self.__departments:
            for employee in department.get_employees():
                writer.writerow([
                    employee.id,
                    employee.name,
                    employee.department,
                    employee.__class__.__name__,
                    f"{employee.base_salary:.2f}",
                    f"{employee.calculate_salary():.2f}"
                ])
```

## Результаты

### Структура проекта
```
LebskijAA12/lab4/
├── project
│   └── Zadanie.py
└── report
    ├── task
    │   ├── lab0401_py_Инкапсуляция.md
    │   ├── lab0402_py_Наследование и Абстракция.md
    │   ├── lab0403_py_Полиморфизм_и_Магические_методы.md
    │   └── lab0404_py_Композиция,_Агрегация_и_Работа_со_сложными_структурами.md
    └── Отчёт.md
```

## Демонстрация работы системы
```python
# Создание сотрудников разных типов
tom2 = Employee(1, "Tom2", "2", 30001)
Bread = Manager(3, "Bread", "4", 30000, 500)
Stiles = Developer(4, "Stiles", "5", 30000, ["C++","C","Python"], "middle")
Brenda = Saleperson(5, "Brenda", "4", 30000, 0.1, 5000)

# Создание отдела и добавление сотрудников
dep = Department("IT")
dep.add_employee(tom2)
dep.add_employee(Bread)
dep.add_employee(Stiles)

# Создание компании и проектов
company = Company("TechCompany")
company.add_department(dep)
project = company.add_project("1", "Web Project", "Разработка веб-приложения", "2024-12-31", "active")

# Демонстрация полиморфизма
employees = [tom2, Bread, Stiles, Brenda]
total_salary = sum(employees)  # Использование __radd__
print(f"Общая зарплата всех сотрудников: {total_salary}")

# Сериализация
company.save_to_json("company_data.json")
company.export_employees_csv("employees_report.csv")
```

## Вывод

В ходе лабораторной работы была успешно разработана комплексная система учета сотрудников компании, реализующая все четыре основных принципа объектно-ориентированного программирования:
Инкапсуляция - достигнута через приватные атрибуты и свойства с валидацией, что обеспечивает защиту данных и контролируемый доступ. Была создана специализированная система валидации через класс `Validator`, который централизованно проверяет корректность идентификаторов, зарплат, дат и статусов. Это не только защищает целостность данных, но и обеспечивает единообразие проверок во всей системе.
Наследование - реализована четкая иерархия классов с абстрактным базовым классом `AbstractEmployee`, что позволяет повторно использовать код и легко расширять систему. Иерархия включает специализированные классы `Manager`, `Developer` и `Salesperson`, каждый из которых наследует общую функциональность, но добавляет свою специфическую логику расчета зарплат и поведения.
Полиморфизм - продемонстрирован через переопределение методов calculate_salary() и get_info() в классах-наследниках, а также через работу с коллекциями объектов разных типов. Особенно показательно использование магических методов (`__add__`, `__eq__`, `__lt__`), которые позволяют работать с объектами сотрудников естественным образом, как с примитивными типами данных.
Композиция и агрегация - использованы для построения сложных структур: проекты содержат команды сотрудников (композиция), компания управляет отделами и проектами (агрегация). Это различие подчеркивает различные отношения между объектами - команда проекта не существует без самого проекта, тогда как отделы могут существовать независимо от компании.   
**Дополнительные аспекты реализации:**
**Принцип единственной ответственности (SRP)** был последовательно применен через:
- Разделение валидации в отдельный класс `Validator`
- Выделение фабрики создания объектов в `EmployeeFactory`
- Специализацию классов под конкретные задачи   

Принцип открытости/закрытости (OCP) проявился в возможности легко добавлять новые типы сотрудников без изменения существующего кода. Система спроектирована так, что расширение функциональности достигается через добавление новых классов, а не модификацию старых.
Система обработки ошибок была значительно улучшена через создание специализированных исключений (`EmployeeNotFoundError`, `DuplicateIdError`, `InvalidStatusError` и др.), что делает код более надежным и удобным для отладки.

**Механизмы сериализации** демонстрируют промышленный подход к работе с данными:
- Полноценная поддержка JSON для сохранения/восстановления состояния системы
- Экспорт в CSV для интеграции с другими системами и отчетности
- Сохранение связей между объектами при сериализации
**Практическая значимость** системы подтверждается:
- Реализацией сложных бизнес-методов (анализ загрузки сотрудников, оптимизация распределения задач)
- Поддержкой различных сценариев использования (назначение на проекты, перевод между отделами)
- Генерацией комплексных отчетов для руководства
Система демонстрирует высокую степень гибкости и расширяемости. Добавление новых типов сотрудников или функциональности не требует изменения существующего кода, что соответствует принципам открытости/закрытости. Реализованные механизмы сериализации и валидации делают систему готовой к промышленному использованию.

Работа позволила глубоко понять и практически применить принципы ООП, что является важной основой для дальнейшего изучения современных технологий программирования и паттернов проектирования. Полученный опыт проектирования сложных объектных систем будет особенно ценен при изучении архитектурных паттернов и frameworks в дальнейшем обучении. Разработанная система служит отличной базой для будущих модификаций и расширений, демонстрируя все преимущества объектно-ориентированного подхода к разработке программного обеспечения.

